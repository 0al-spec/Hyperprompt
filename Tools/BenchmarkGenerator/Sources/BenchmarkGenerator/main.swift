import Foundation

struct CorpusGenerator {
    let fileCount: Int = 50
    let targetLines: Int = 5000
    let linkDensity: Double = 5.0 // average links per file

    let modules = [
        "auth", "database", "api", "cache", "queue",
        "storage", "config", "logging", "metrics", "workers"
    ]

    func generate(at outputPath: String) throws {
        let fm = FileManager.default

        // Create base directory
        try fm.createDirectory(atPath: outputPath, withIntermediateDirectories: true)

        // Generate entry file
        try generateEntryFile(at: outputPath)

        // Generate module files
        for (moduleIndex, moduleName) in modules.enumerated() {
            let modulePath = "\(outputPath)/modules/\(moduleName)"
            try fm.createDirectory(atPath: modulePath, withIntermediateDirectories: true)

            // 4-5 files per module
            let filesInModule = (moduleIndex < 5) ? 5 : 4
            for fileIndex in 0..<filesInModule {
                try generateModuleFile(
                    moduleName: moduleName,
                    fileIndex: fileIndex,
                    filesInModule: filesInModule,
                    at: modulePath
                )
            }
        }

        print("✓ Generated \(fileCount) files at \(outputPath)")
        let totalLines = try countTotalLines(at: outputPath)
        print("✓ Total lines: \(totalLines) (target: \(targetLines))")
    }

    private func generateEntryFile(at basePath: String) throws {
        let filePath = "\(basePath)/entry.hc"
        var content = """
        # Application Entry Point

        This is the main entry point for the Hyperprompt benchmark corpus.
        It demonstrates typical project structure with multiple modules.

        ## Architecture Overview

        The application is organized into the following modules:

        """

        // Reference all modules
        for moduleName in modules {
            content += "- **\(moduleName.capitalized)**: [modules/\(moduleName)/index.hc](modules/\(moduleName)/index.hc)\n"
        }

        content += "\n## Module Descriptions\n\n"

        for moduleName in modules {
            content += """
            ### \(moduleName.capitalized) Module

            The \(moduleName) module provides core functionality for \(moduleName) operations.
            See [modules/\(moduleName)/index.hc](modules/\(moduleName)/index.hc) for details.


            """
        }

        content += """
        ## Getting Started

        To understand the system architecture, start by reviewing each module:

        1. Authentication: [modules/auth/index.hc](modules/auth/index.hc)
        2. Database: [modules/database/index.hc](modules/database/index.hc)
        3. API Layer: [modules/api/index.hc](modules/api/index.hc)

        ## Configuration

        System configuration is managed in [modules/config/index.hc](modules/config/index.hc).

        ## Monitoring

        Metrics and logging are handled by:
        - Logging: [modules/logging/index.hc](modules/logging/index.hc)
        - Metrics: [modules/metrics/index.hc](modules/metrics/index.hc)

        ---

        Generated by BenchmarkGenerator for performance testing.
        """

        try content.write(toFile: filePath, atomically: true, encoding: .utf8)
    }

    private func generateModuleFile(
        moduleName: String,
        fileIndex: Int,
        filesInModule: Int,
        at modulePath: String
    ) throws {
        let fileNames = ["index", "core", "utils", "types", "impl"]
        let fileName = fileNames[fileIndex]
        let filePath = "\(modulePath)/\(fileName).hc"

        var content = "# \(moduleName.capitalized) — \(fileName.capitalized)\n\n"

        // Add description
        content += "This module handles \(moduleName) \(fileName) functionality.\n\n"

        // Add sections with varying depths
        let sections = generateSections(
            moduleName: moduleName,
            fileName: fileName,
            lineTarget: targetLines / fileCount
        )
        content += sections

        // Add cross-references to other files in module
        if fileIndex == 0 { // index file references others
            content += "\n## Related Components\n\n"
            for otherIndex in 1..<filesInModule {
                let otherName = fileNames[otherIndex]
                content += "- [\(otherName.capitalized)](\(otherName).hc)\n"
            }
        }

        // Add cross-module references (average ~5 per file)
        content += "\n## Dependencies\n\n"
        let linkCount = Int(linkDensity)
        for i in 0..<linkCount {
            let refModule = modules[(modules.firstIndex(of: moduleName)! + i + 1) % modules.count]
            let refFile = fileNames[i % fileNames.count]
            content += "- [\(refModule.capitalized) \(refFile)]"
            content += "(../\(refModule)/\(refFile).hc)\n"
        }

        content += "\n---\n\nGenerated by BenchmarkGenerator.\n"

        try content.write(toFile: filePath, atomically: true, encoding: .utf8)
    }

    private func generateSections(moduleName: String, fileName: String, lineTarget: Int) -> String {
        var content = ""
        // Aim for more content: ~70 lines of actual content per file
        let sectionsNeeded = 8

        for sectionIndex in 0..<sectionsNeeded {
            content += "## \(fileName.capitalized) Section \(sectionIndex + 1)\n\n"

            // 2-3 paragraphs per section
            let paragraphs = (sectionIndex % 2 == 0) ? 3 : 2
            for paraIndex in 0..<paragraphs {
                content += generateParagraph(index: sectionIndex * 10 + paraIndex)
                content += "\n\n"

                // Add some code examples every few paragraphs
                if (sectionIndex + paraIndex) % 4 == 0 {
                    content += generateCodeExample(moduleName: moduleName, index: sectionIndex)
                    content += "\n\n"
                }
            }

            // Add subsections for variety
            if sectionIndex % 3 == 0 {
                content += "### Implementation Details\n\n"
                content += generateParagraph(index: sectionIndex + 100)
                content += "\n\n"
            }
        }

        return content
    }

    private func generateCodeExample(moduleName: String, index: Int) -> String {
        return """
        ```swift
        // Example implementation for \(moduleName)
        struct \(moduleName.capitalized)Handler {
            func process() async throws -> Result {
                // Processing logic here
                return .success
            }
        }
        ```
        """
    }

    private func generateParagraph(index: Int) -> String {
        let templates = [
            "This component provides essential functionality for managing \(index) operations. It integrates seamlessly with the core system architecture.",
            "The implementation uses modern Swift patterns including async/await, structured concurrency, and strong type safety.",
            "Key features include automatic error recovery, comprehensive logging, and performance optimization through caching strategies.",
            "This module is designed for high throughput scenarios, supporting concurrent operations while maintaining data consistency.",
            "Integration points are clearly defined through protocol-based abstractions, enabling easy testing and modularity.",
            "Performance characteristics have been optimized for typical workloads, with special attention to memory efficiency.",
            "The architecture follows SOLID principles, ensuring maintainability and extensibility for future enhancements."
        ]

        return templates[index % templates.count]
    }

    private func countTotalLines(at path: String) throws -> Int {
        var totalLines = 0
        let fm = FileManager.default
        let enumerator = fm.enumerator(atPath: path)

        while let file = enumerator?.nextObject() as? String {
            guard file.hasSuffix(".hc") else { continue }
            let filePath = "\(path)/\(file)"
            let content = try String(contentsOfFile: filePath, encoding: .utf8)
            totalLines += content.components(separatedBy: .newlines).count
        }

        return totalLines
    }
}

// Main execution
let generator = CorpusGenerator()
let outputPath = "../../Tests/PerformanceTests/Fixtures/MediumProject"

// Get absolute path
let currentDir = FileManager.default.currentDirectoryPath
let absoluteOutputPath = URL(fileURLWithPath: outputPath, relativeTo: URL(fileURLWithPath: currentDir))
    .standardized.path

do {
    try generator.generate(at: absoluteOutputPath)
    print("\n✅ Benchmark corpus generation complete!")
} catch {
    print("❌ Error generating corpus: \(error)")
    exit(1)
}
